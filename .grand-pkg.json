{"lines": {"blank": 136, "comment": 10, "docstring": 611, "code": 325}, "pep8": {"count": 42, "categories": [["1", "E129", "visually indented line with same indent as next logical line"], ["9", "E231", "missing whitespace after ','"], ["10", "E303", "too many blank lines (2)"], ["1", "E402", "module level import not at top of file"], ["19", "E501", "line too long (114 > 79 characters)"], ["1", "E711", "comparison to None should be 'if cond is None:'"], ["1", "W291", "trailing whitespace"]]}, "doc": {"statistics": {"grand_tools/__init__.py": {"tokens": {}, "n_errors": 0, "n_tokens": 1}, "grand_tools/astro.py": {"tokens": {"AstroConversion.__init__": [36, ["Undocumented parameter `ra`", "Missing description", "Undocumented parameter `latitude`", "Undocumented parameter `dec`", "Undocumented parameter `longitude`", "Undocumented parameter `altitude`"]]}, "n_errors": 6, "n_tokens": 16}, "grand_tools/topography.py": {"tokens": {}, "n_errors": 0, "n_tokens": 11}, "grand_tools/geomagnet.py": {"tokens": {}, "n_errors": 0, "n_tokens": 16}, "grand_tools/coordinates/representation.py": {"tokens": {}, "n_errors": 0, "n_tokens": 24}, "grand_tools/coordinates/frame.py": {"tokens": {"ECEF.__init__": [53, ["Undocumented parameter `**kwargs`", "Undocumented parameter `*args`"]], "ENU.__init__": [160, ["Undocumented parameter `**kwargs`", "Undocumented parameter `*args`"]]}, "n_errors": 4, "n_tokens": 51}}, "doc": "Common tools for GRAND packages", "classes": {}, "definitions": {"DATADIR": [33, "Path to the package data", null]}, "functions": {}, "imports": {"1": {"": [["astro", "astro"]]}}, "path": "grand_tools/__init__.py", "__all__": ["DATADIR", "astro"], "modules": {"astro": {"doc": "Common tools for GRAND packages", "classes": {"AstroConversion": [27, "This class handles astronomical conversion, such as coordinate transformation from alt-az on local site to sky\ncoordinates.\n\nTodo\n----\n- [ ] Convert from print to logger (grand-mother/tools#1) ", {"attributes": {}, "methods": {"__init__": [36, "", {"parameters": {"longitude": null, "latitude": null, "altitude": null, "ra": null, "dec": null}, "prototype": "cls, longitude=None, latitude=None, altitude=None, ra=None, dec=None"}], "to_skycoord": [51, "Transforms an input direction given in a local site from alt-az system (theta, phi) to\n`~astropy.coordinates.SkyCoord` sky coordinates.\n\nGRAND convention: receiver convention: phi is oriented West of North, theta from zenith\n\n```\n      z=Up\n      /\\\n      |\n      |\n      | theta\n      |- /.\n      | / .\n      |/  .\n      --------------> y=West\n     / .  .\n    / / . .\n   /-     .\n  /   phi\n |/\nx=North\n```\n", {"parameters": {"theta": ["array, scalar, Quantity, Angle", "Local azimuth of the event"], "phi": ["array, scalar, Quantity, Angle", "Local altitude of the event"], "time": ["sequence, ndarray, number, str, bytes, or Time object", "Time to use to compute the AltAz coordinates, instance of `~astropy.time.Time`"], "coordsys": ["class or frame object or SkyCoord object", "Coordinate system to use, can be an instance of `~astropy.coordinates` such as ICRS,"]}, "prototype": "cls, theta=None, phi=None, time=None, coordsys=ICRS", "returns": [["ICRS", "Sky coordinates in 'ICRS'", ""]]}], "localsiderealtime": [101, "Provide the local sidereal time\n", {"parameters": {"time": ["sequence, ndarray, number, str, bytes, or Time object", "Input time, in whatever time scale supported by `~astropy.time.Time`"]}, "prototype": "cls, time", "returns": [["Longitude", "Local sidereal time", ""]]}]}, "bases": []}]}, "definitions": {}, "functions": {}, "imports": {}, "path": "grand_tools/astro.py"}, "topography": {"doc": "Topography wrapper for GRAND packages", "classes": {"Topography": [80, "Proxy to topography data", {"attributes": {}, "methods": {"__init__": [83, "Initialise a topography wrapper\n\nAlternative geomagnetic models can be instanciated with this class.\nInstead, use the `field` function of the geomagnet module in order to\nget the GRAND standard geomagnetic model.\n\nExamples\n--------\n```\n>>> from grand_tools.topography import Topography\n\n>>> topography = Topography(\"SRTMGL1\")\n\n```", {"parameters": {"path": ["str", "Path to the topography data"]}, "prototype": "self, path", "raises": [["grand_libs.turtle.LibraryError", "The provided data are not valid / available"]]}], "elevation": [112, "Get the topography elevation, w.r.t. sea level\n\nThis method accepts vectorized input. The returned value is in unit\n`astropy.Unit.m`.\n\nExamples\n--------\n```\n>>> from grand_tools.coordinates import ECEF\n>>> from grand_tools.topography import Topography\n\n>>> topography = Topography(\"SRTMGL1\")\n>>> coordinates = ECEF(representation_type=\"geodetic\", latitude=45,\n...                    longitude=3, obstime=\"2019-01-01\")\n>>> elevation = topography.elevation(coordinates)\n\n```", {"parameters": {"coordinates": ["ECEF or ENU", "The coordinates of points where the elevation is requested"]}, "prototype": "self, coordinates", "returns": [["astropy.Quantity", "The topography elevation at the given point(s)", ""]]}]}, "bases": []}]}, "definitions": {}, "functions": {"geoid_undulation": [35, "Get the geoid undulation\n\nThis method accepts vectorized input. The returned value is in unit\n`astropy.Unit.m`.\n\nExamples\n--------\n```\n>>> from grand_tools.coordinates import ECEF\n>>> from grand_tools import topography\n\n>>> coordinates = ECEF(representation_type=\"geodetic\", latitude=45,\n...                    longitude=3, obstime=\"2019-01-01\")\n>>> undulation = topography.geoid_undulation(coordinates)\n\n```", {"parameters": {"coordinates": ["ECEF or ENU", "The coordinates of points where the undulation is requested"]}, "prototype": "coordinates", "returns": [["astropy.Quantity", "The geoid undulation at the given point(s)", ""]]}]}, "imports": {}, "path": "grand_tools/topography.py"}, "geomagnet": {"doc": "Geomagnetic field wrapper for GRAND packages", "classes": {"Geomagnet": [38, "Proxy to a geomagnetic model", {"attributes": {}, "methods": {"__init__": [41, "Initialise a geomagnet wrapper\n\nAlternative geomagnetic models can be instanciated with this class.\nInstead, use the `field` function of the geomagnet module in order to\nget the GRAND standard geomagnetic model.\n\nNotes\n-----\nIn order to get the geomagnetic field from the default GRAND model\n(IGRF12), one should **not** directly instantiate this class.  Instead\none should use the `field` function of the geomagnet module.  This class\nis only meant to be used for studies of the impact of alternative\nmodels.\n\nSupported models are:\n  1. [IGRF12](https://www.ngdc.noaa.gov/IAGA/vmod/igrf.html)\n  2. [WMM2015](http://www.geomag.bgs.ac.uk/research/modelling/WorldMagneticModel.html)\n\nExamples\n--------\n```\n>>> from grand_tools.geomagnet import Geomagnet\n\n>>> geomagnet = Geomagnet(\"WWM2015\")\n\n```", {"parameters": {"model": ["str, optional", "The geomagnetic model (defaults to \"IGRF12\")"]}, "prototype": "self, model=None", "raises": [["grand_libs.gull.LibraryError", "The requested model is not valid / available"]]}], "field": [85, "Get the geo-magnetic field components\n\nThis method accepts vectorized input. The frame of the returned value\ndepends on the input size. If a single point is provided the magnetic\nfield is returned in local ENU coordinates, centered on the point.\nOtherwise the components are given in ECEF.\n\nExamples\n--------\n```\n>>> from grand_tools.coordinates import ECEF\n>>> from grand_tools.geomagnet import Geomagnet\n\n>>> geomagnet = Geomagnet()\n>>> coordinates = ECEF(representation_type=\"geodetic\", latitude=45,\n...                    longitude=3, obstime=\"2019-01-01\")\n>>> field = geomagnet.field(coordinates)\n\n```", {"parameters": {"coordinates": ["ECEF or ENU", "The coordinates of points where the magnetic field is requested"]}, "prototype": "self, coordinates", "returns": [["ECEF or ENU", "The magnetic field components at the given point(s)", ""]], "raises": [["ValueError", "The provided coordinates are not valid"]]}]}, "bases": []}]}, "definitions": {}, "functions": {"field": [165, "Get the geo-magnetic field\n\nThis method accepts vectorized input. The frame of the returned value\ndepends on the input size. If a single point is provided the magnetic\nfield is returned in local ENU coordinates, centered on the point.\nOtherwise the components are given in ECEF.\n\nExamples\n--------\n```\n>>> from grand_tools.coordinates import ECEF\n>>> from grand_tools import geomagnet\n\n>>> coordinates = ECEF(representation_type=\"geodetic\", latitude=45,\n...                    longitude=3, obstime=\"2019-01-01\")\n>>> field = geomagnet.field(coordinates)\n\n```", {"parameters": {"coordinates": ["ECEF or ENU", "The coordinates of points where the magnetic field is requested"]}, "prototype": "coordinates", "returns": [["ECEF or ENU", "The magnetic field components at the given point(s)", ""]], "raises": [["ValueError", "The provided coordinates are not valid"]]}], "model": [207, "Get the default model for the geo-magnetic field\n\nCurrently the default geomagnetic model used in GRAND is\n[IGRF12](https://www.ngdc.noaa.gov/IAGA/vmod/igrf.html).\n\nExamples\n--------\n```\n>>> from grand_tools import geomagnet\n\n>>> geomagnet.model()\n'IGRF12'\n\n```", {"parameters": {}, "prototype": "", "returns": [["str", "The name of the default model", ""]]}]}, "imports": {}, "path": "grand_tools/geomagnet.py"}, "coordinates": {"doc": "GRAND extension of astropy.coordinates", "classes": {"ECEF": [42, "Earth-Centered Earth-Fixed frame, co-moving with the Earth\n    ", {"attributes": {"default_representation": [46, "Default representation of local frames", null], "obstime": [49, "The observation time", null]}, "methods": {"__init__": [53, "Initialisation of an ECEF frame\n", {"parameters": {"obstime": ["Time or datetime or str, optional", "The observation time"], "*args": null, "**kwargs": null}, "prototype": "self, *args, obstime=None, **kwargs"}]}, "bases": ["BaseCoordinateFrame"]}, "grand_tools/coordinates/frame.py"], "ENU": [140, "Local geographic frames on the Earth, oriented along cardinal directions\n    ", {"attributes": {"default_representation": [144, "Default representation of local frames", null], "location": [147, "The origin on Earth of the local frame", null], "orientation": [150, "The orientation of the local frame, as cardinal directions", null], "magnetic": [153, "When enabled, use the magnetic North instead of the geographic one", null], "obstime": [156, "The observation time", null]}, "methods": {"__init__": [160, "Initialisation of a local frame\n", {"parameters": {"location": ["EarthLocation", "The location on Earth of the local frame origin"], "orientation": ["sequence of str, optional", "The cardinal directions of the x, y, and z axis (default: E, N, U)"], "magnetic": ["boolean, optional", "Use the magnetic north instead of the geographic one (default: false)"], "obstime": ["Time or datetime or str, optional", "The observation time"], "*args": null, "**kwargs": null}, "prototype": "self, *args, location=None, orientation=None, magnetic=False, obstime=None, **kwargs", "raises": [["ValueError", "The local frame configuration is not valid"]]}]}, "bases": ["BaseCoordinateFrame"]}, "grand_tools/coordinates/frame.py"], "GeodeticRepresentation": [32, "Geodetic coordinates representation w.r.t. the WGS84 ellipsoid", {"attributes": {"attr_classes": [35, "Attributes of a Geodetic representation", null]}, "methods": {"__init__": [41, "Initialise a geodetic representation\n", {"parameters": {"latitude": ["Quantity or str", "The latitude angle measured clockwise, w.r.t. the xOy plane"], "longitude": ["Quantity or str", "The longitude angle measured counter-clockwise, w.r.t. the x-axis"], "height": ["Quantity or str", "The height above the WGS84 ellipsoid"], "copy": ["bool, optional", "If `True` (default), arrays will be copied rather than referenced"]}, "prototype": "self, latitude, longitude, height=0, copy=True"}], "from_cartesian": [59, "Generate a Geodetic representation from a Cartesian one\n", {"parameters": {"cart": ["CartesianRepresentation", "The cartesian coordinates of a point, e.g. in ITRS"]}, "prototype": "cls, cart", "returns": [["GeodeticRepresentation", "The corresponding geodetic coordinates", ""]]}], "to_cartesian": [85, "Generate a Cartesian representation from a Geodetic one\n", {"parameters": {}, "prototype": "self", "returns": [["CartesianRepresentation", "The Cartesian coordinates corresponding to this representation", ""]]}]}, "bases": ["BaseRepresentation"]}, "grand_tools/coordinates/representation.py"], "HorizontalRepresentation": [104, "Horizontal angular representation, for unit vectors", {"attributes": {"attr_classes": [108, "Attributes of a Horizontal representation", null]}, "methods": {"__init__": [113, "Initialise a Horizontal angular representation of a unit vector\n", {"parameters": {"azimuth": ["Quantity or str", "The azimuth angle measured clockwise, w.r.t. the y axis"], "elevation": ["Quantity or str", "The elevation angle measured clockwise, w.r.t. the xOy plane"], "copy": ["bool, optional", "If `True` (default), arrays will be copied rather than referenced"]}, "prototype": "self, azimuth, elevation, copy=True"}], "from_cartesian": [129, "Generate a Horizontal angular representation from a Cartesian unit\nvector\n\n**Note** that the Cartesian unit vector **must** be dimensioneless.\nThough it is not checked if the norm of the vector is indeed unity.\n", {"parameters": {"cart": ["CartesianRepresentation", "The cartesian coordinates of the unit vector"]}, "prototype": "cls, cart", "returns": [["HorizontalRepresentation", "The corresponding angular coordinates", ""]], "raises": [["ValueError", "The cartesian representation is not dimensioneless"]]}], "to_cartesian": [169, "Generate a Cartesian unit vector from this Horizontal angular\nrepresentation\n", {"parameters": {}, "prototype": "self", "returns": [["CartesianRepresentation", "The corresponding cartesian unit vector", ""]]}]}, "bases": ["BaseRepresentation"]}, "grand_tools/coordinates/representation.py"]}, "definitions": {}, "functions": {}, "imports": {"1": {"frame": [["ECEF", "ECEF"], ["ENU", "ENU"]], "representation": [["GeodeticRepresentation", "GeodeticRepresentation"], ["HorizontalRepresentation", "HorizontalRepresentation"]]}}, "path": "grand_tools/coordinates/__init__.py", "__all__": ["ECEF", "ENU", "GeodeticRepresentation", "HorizontalRepresentation"], "modules": {"representation": {"doc": "Extra representations for astropy.coordinates", "classes": {"GeodeticRepresentation": [32, "Geodetic coordinates representation w.r.t. the WGS84 ellipsoid", {"attributes": {"attr_classes": [35, "Attributes of a Geodetic representation", null]}, "methods": {"__init__": [41, "Initialise a geodetic representation\n", {"parameters": {"latitude": ["Quantity or str", "The latitude angle measured clockwise, w.r.t. the xOy plane"], "longitude": ["Quantity or str", "The longitude angle measured counter-clockwise, w.r.t. the x-axis"], "height": ["Quantity or str", "The height above the WGS84 ellipsoid"], "copy": ["bool, optional", "If `True` (default), arrays will be copied rather than referenced"]}, "prototype": "self, latitude, longitude, height=0, copy=True"}], "from_cartesian": [59, "Generate a Geodetic representation from a Cartesian one\n", {"parameters": {"cart": ["CartesianRepresentation", "The cartesian coordinates of a point, e.g. in ITRS"]}, "prototype": "cls, cart", "returns": [["GeodeticRepresentation", "The corresponding geodetic coordinates", ""]]}], "to_cartesian": [85, "Generate a Cartesian representation from a Geodetic one\n", {"parameters": {}, "prototype": "self", "returns": [["CartesianRepresentation", "The Cartesian coordinates corresponding to this representation", ""]]}]}, "bases": ["BaseRepresentation"]}], "HorizontalRepresentation": [104, "Horizontal angular representation, for unit vectors", {"attributes": {"attr_classes": [108, "Attributes of a Horizontal representation", null]}, "methods": {"__init__": [113, "Initialise a Horizontal angular representation of a unit vector\n", {"parameters": {"azimuth": ["Quantity or str", "The azimuth angle measured clockwise, w.r.t. the y axis"], "elevation": ["Quantity or str", "The elevation angle measured clockwise, w.r.t. the xOy plane"], "copy": ["bool, optional", "If `True` (default), arrays will be copied rather than referenced"]}, "prototype": "self, azimuth, elevation, copy=True"}], "from_cartesian": [129, "Generate a Horizontal angular representation from a Cartesian unit\nvector\n\n**Note** that the Cartesian unit vector **must** be dimensioneless.\nThough it is not checked if the norm of the vector is indeed unity.\n", {"parameters": {"cart": ["CartesianRepresentation", "The cartesian coordinates of the unit vector"]}, "prototype": "cls, cart", "returns": [["HorizontalRepresentation", "The corresponding angular coordinates", ""]], "raises": [["ValueError", "The cartesian representation is not dimensioneless"]]}], "to_cartesian": [169, "Generate a Cartesian unit vector from this Horizontal angular\nrepresentation\n", {"parameters": {}, "prototype": "self", "returns": [["CartesianRepresentation", "The corresponding cartesian unit vector", ""]]}]}, "bases": ["BaseRepresentation"]}]}, "definitions": {}, "functions": {}, "imports": {}, "path": "grand_tools/coordinates/representation.py", "__all__": ["GeodeticRepresentation", "HorizontalRepresentation"]}, "frame": {"doc": "Extra frame(s) for astropy.coordinates", "classes": {"ECEF": [42, "Earth-Centered Earth-Fixed frame, co-moving with the Earth\n    ", {"attributes": {"default_representation": [46, "Default representation of local frames", null], "obstime": [49, "The observation time", null]}, "methods": {"__init__": [53, "Initialisation of an ECEF frame\n", {"parameters": {"obstime": ["Time or datetime or str, optional", "The observation time"], "*args": null, "**kwargs": null}, "prototype": "self, *args, obstime=None, **kwargs"}]}, "bases": ["BaseCoordinateFrame"]}], "ENU": [140, "Local geographic frames on the Earth, oriented along cardinal directions\n    ", {"attributes": {"default_representation": [144, "Default representation of local frames", null], "location": [147, "The origin on Earth of the local frame", null], "orientation": [150, "The orientation of the local frame, as cardinal directions", null], "magnetic": [153, "When enabled, use the magnetic North instead of the geographic one", null], "obstime": [156, "The observation time", null]}, "methods": {"__init__": [160, "Initialisation of a local frame\n", {"parameters": {"location": ["EarthLocation", "The location on Earth of the local frame origin"], "orientation": ["sequence of str, optional", "The cardinal directions of the x, y, and z axis (default: E, N, U)"], "magnetic": ["boolean, optional", "Use the magnetic north instead of the geographic one (default: false)"], "obstime": ["Time or datetime or str, optional", "The observation time"], "*args": null, "**kwargs": null}, "prototype": "self, *args, location=None, orientation=None, magnetic=False, obstime=None, **kwargs", "raises": [["ValueError", "The local frame configuration is not valid"]]}]}, "bases": ["BaseCoordinateFrame"]}]}, "definitions": {}, "functions": {"itrs_to_ecef": [68, "Compute the transformation from ITRS to ECEF coordinates\n", {"parameters": {"itrs": ["ITRS", "The initial coordinates in ITRS"], "ecef": ["ECEF", "The ECEF frame to transform to"]}, "prototype": "itrs, ecef", "returns": [["ECEF", "The ECEF frame with transformed coordinates", ""]]}], "ecef_to_itrs": [93, "Compute the transformation from ECEF to ITRS coordinates\n", {"parameters": {"ecef": ["ECEF", "The initial coordinates in ECEF"], "itrs": ["ITRS", "The ITRS frame to transform to"]}, "prototype": "ecef, itrs", "returns": [["ITRS", "The ITRS frame with transformed coordinates", ""]]}], "ecef_to_ecef": [118, "Compute the transformation from ECEF to ECEF coordinates\n", {"parameters": {"ecef0": ["ECEF", "The initial coordinates in the 1st ECEF frame"], "ecef1": ["ECEF", "The 2nd ECEF frame to transform to"]}, "prototype": "ecef0, ecef1", "returns": [["ECEF", "The ECEF frame with transformed coordinates", ""]]}], "itrs_to_enu": [244, "Compute the transformation from ECEF to ENU coordinates\n", {"parameters": {"ecef": ["ECEF", "The initial coordinates in ECEF"], "enu": ["ENU", "The ENU frame to transform to"]}, "prototype": "ecef, enu", "returns": [["ENU", "The ENU frame with transformed coordinates", ""]]}], "enu_to_itrs": [272, "Compute the transformation from ENU to ECEF coordinates\n", {"parameters": {"enu": ["ENU", "The initial coordinates in ENU"], "ecef": ["ECEF", "The ECEF frame to transform to"]}, "prototype": "enu, ecef", "returns": [["ECEF", "The ECEF frame with transformed coordinates", ""]]}], "enu_to_enu": [298, "Compute the transformation from ENU to ENU coordinates\n", {"parameters": {"enu0": ["ENU", "The initial coordinates in the 1st ENU frame"], "enu1": ["ENU", "The 2nd ENU frame to transform to"]}, "prototype": "enu0, enu1", "returns": [["ENU", "The ENU frame with transformed coordinates", ""]]}]}, "imports": {}, "path": "grand_tools/coordinates/frame.py", "__all__": ["ECEF", "ENU"]}}}}}, "package": {"description": "Common tools for GRAND packages", "name": "grand_tools", "git-name": "tools", "dist-name": "grand-tools"}, "manager": {"version": "0.1.9", "git": {"sha1": "a9ef52703ae58e3ed7382b6e9bbf356a1a1c2e4b", "author": "Valentin Niess", "date": "2019-04-08 00:30:15 +0200", "count": 55}}}
